{"componentChunkName":"component---src-templates-blogs-post-js","path":"/blog/2021/zero-to-hero-containerizing-dotnet-5-webapis/","result":{"data":{"site":{"siteMetadata":{"title":"David Kröll"}},"markdownRemark":{"id":"43a426c6-e68f-524c-a1e3-d88abf4a289c","excerpt":"In this guide I’d like to show the most important topics and aspects when talking about containerizing a .NET 5.0 WebApi application.\nThere…","rawMarkdownBody":"\nIn this guide I'd like to show the most important topics and aspects when talking about containerizing a .NET 5.0 WebApi application.\nThere are many articles about it online but no one takes care of all aspects - until now.\nWith this guide you'd be able to go from zero :zero: to hero :mount_fuji: when talking about containers and .NET 5.0 WebApi.\n\n> This articles focuses on building the app inside a Linux container. \nI won't talk about .NET Framework (4.x) which would require the Windows platform to run.\n\n### What's inside\n\nThe following topics are going to be considered in this guide:\n\n* Configuration\n* Testing\n* OpenAPI spec (Swaggerfile) generation\n* Image size optimizations\n* Container security\n* Overwriting defaults\n\n## Intial Dockerfile setup\n\nThis is the base version we are going to improve step by step in this guide.\nThe major downside is, that there is much more included in the\nfinal image than we need for production use.\n\n```Dockerfile\nFROM mcr.microsoft.com/dotnet/sdk:5.0-alpine AS build\nWORKDIR /source\n\n# Copy and restore\nCOPY . .\n# make sure this is set in the RuntimeIdentifiers of the .csproj\nRUN dotnet restore -r linux-musl-x64\n\n# publish project (StartupProject is the startup project)\nRUN dotnet publish -c Release -o /appReleased -r linux-musl-x64 \\\n    --no-restore StartupProject/*.csproj\n\nENTRYPOINT [\"/appReleased/StartupProject\"]\n```\n\n\n## Configuration\n\nApplication configuration is nowadays typically done in `appsettings.json`.\nNevertheless there are a bunch more configuration providers pre-built in the ASP .NET Core 5.0 framework.\nThese include the following:\n* Environment variables\n* Command line args\n* Directory files\n\nIn fact it does matter in which order you apply these setting because they can overwrite each other.\nThis powerful feature enables us to have some default configuration which can be overwritten at runtime.\n\nMy way of configuring the application is a mixture of the `appsettings.json` file and environment variables.\n\nSince the settings file is a JSON, nesting is possible.\nWhen providing configuration with environment variables,\nyou should split these using `__` (a `double underline`).\n\nTaking the following file as example:\n\n```json\n// appsettings.json\n{\n    \"JWT\": {\n        \"Secret\": \"\"\n    }\n    // ...\n}\n```\n\nAssuming the configuration file from above,\noverwriting with environment variables\nis possible with the following statement:\n\n```bash\nexport JWT__Secret=superSecureJWTSecret\n```\n\nI don't want the secrets like external API keys, JWT details, etc.\ninside my Git history, so they are provided as environment variables at application runtime.\n\nI'm using the settings file for a basic default configuration\nand the environment variables for the complete setup.\nAs already mentioned above, the environment variables will overwrite configuration done in\n`appsettings.json`, when the same key is provided. \n\n## Testing\n\nRunning tests every time you build your application is a crucial part of any CI pipeline,\nand executing them inside an isolated environment is even better.\n\nRunning unit tests within the new .NET 5.0 ecosystem is as easy as calling a single command with the .NET CLI:\n\n```Dockerfile\nRUN dotnet test --no-restore\n```\n\nBecause we restored the project right before,\nwe do not need to restore again (which would be the default behaviour).\nThis implies that we can save some CI-Pipeline time with the `--no-restore` flag.\n\n\n## OpenAPI spec (Swaggerfile) generation\n\nA very popular NuGet for a ASP .NET Core 5.0 projects is the\n[`Swashbuckle.AspNetCore`](https://www.nuget.org/packages/Swashbuckle.AspNetCore/)\nwhich provides automatic OpenAPI generation.\n\nMost of the users may not know the dotnet CLI tool they provide.\nWith this tool it is possible to generate the OpenAPI spec directly\nfrom the startup assembly. \n\n```bash\ndotnet tool install --version 6.1.1 Swashbuckle.AspNetCore.Cli\n```\n\n> :warning: Make sure you use the same version of the CLI tool\nand the NuGet, otherwise it will result in some strange error.\n\nThere should now be a `dotnet-tools` config present, which stores all\ninstalled tools and corresponding versions.\nThis is important as this file is required for the build process later on.\nMake sure to also include it in your Git repository.\n\n\n```Dockerfile\n# build swagger.json from controller/endpoint definitions\nRUN dotnet tool restore \\\n        dotnet swagger tofile --output swagger.json StartupProject/bin/Debug/net5.0/StartupProject.dll v1\n```\n\nThe OpenAPI specification is now written as JSON file inside the built image.\nYou can for example build a client with the OpenAPI toolkit or just save it for later use.\n\nFor building a seperate client, another stage in your Dockerfile would be applicable.\n\n> Official [Docker docs on multi-stage builds](https://docs.docker.com/develop/develop-images/multistage-build/)\n\n## Image size and multi-staged builds\n\nUntil now the build process only spits out my own application and it's dependencies.\nAs of now, the correct .NET runtime has to be installed and managed seperately.\nThis is also called **framework-dependent**.\nIndeed, there is another type of building and publishing an application.\nThat's called the **self-contained** release.\nWhen using this, the runtime is provided together with the application code itself.\nAs a result, the runtime doesn't need to be installed seperately.\n\nAnother requirement for using `self-contained` as publishing type is, to make sure that the correct `RuntimeIdentifier` in your `.csproj` file is set.\n\n```xml\n<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n    <PropertyGroup>\n        <TargetFramework>net5.0</TargetFramework>\n        <RuntimeIdentifiers>linux-musl-x64</RuntimeIdentifiers>\n        <OutputType>Exe</OutputType>\n    </PropertyGroup>\n\n</Project>\n```\n\nFor the **Alpine** distribution as base image, the `linux-musl-x64` has to be added.\nYou may enable multiple RuntimeIdentifers (seperated by \";\") in order\nto make it executable also on other platforms as self-contained build (for example `win-x64`).\n\nNow the finally built binary has fewer dependencies than the base image we used before provides.\nMicrosoft has also for this an answer: the base-image `mcr.microsoft.com/dotnet/runtime-deps:5.0-alpine-amd64`\nincludes everything just to run `self-contained` apps.\n\nIt is now possible to switch to a multi-staged Docker build:\n\n```Dockerfile\n# Build stage\nFROM mcr.microsoft.com/dotnet/sdk:5.0-alpine AS build\nWORKDIR /source\n\n# Copy csproj and restore as distinct layers\nCOPY . .\nRUN dotnet restore -r linux-musl-x64\n\nRUN dotnet test --no-restore\n\n# build swagger.json from controller/endpoint definitions\nRUN dotnet tool restore \\\n        dotnet swagger tofile --output swagger.json StartupProject/bin/Debug/net5.0/StartupProject.dll v1\n\n# publish project (StartupProject is the startup project)\nRUN dotnet publish -c Release -o /appReleased -r linux-musl-x64 \\\n    --no-restore StartupProject/*.csproj\n\n# Create final image\nFROM mcr.microsoft.com/dotnet/runtime-deps:5.0-alpine-amd64\nCOPY --from=build /appReleased /app\n\nENTRYPOINT [\"/app/StartupProject\"]\n```\n\n## Security\n\nFrom the security point of view, it's important to run your\nAPI in the context of a user with minimal operating system permissions.\nThe default if not specified would be the `root` user, but\nthere are multiple drawdowns when using the  superuser with Docker.\n\nHowever a detailed explanation would go beyond the scope of this article.\n\n> You can follow along here for details: https://sysdig.com/blog/dockerfile-best-practices/\n\nRunning apps under another user is as easy as applying the following statements to your Dockerfile:\n\n\n```Dockerfile\n# (truncated)\n# Add user, group, and change ownership\nRUN adduser --disabled-password --gecos \"\" --home /app --no-create-home --uid 10001 appuser \\\n    # make sure to allow your user to access your application binary\n    && chown -R appuser:appuser /app\n\nUSER appuser\n# (truncated)\n```\n\n## Overriding defaults \n\nIn case you wondered where the default listening port is configured:\nI am going to demistify it now.\n\n\nThe base image we are using here in the final layer has some default configuration\nand the listening URL and port is included there.\n\n> You can view the base\n[Dockerfile](https://github.com/dotnet/dotnet-docker/blob/main/src/runtime-deps/3.1/alpine3.13/amd64/Dockerfile) \nhere\n\nThe specific section I am talking about is this one:\n\n```Dockerfile\n# ...\nENV \\\n    # Configure web servers to bind to port 80 when present\n    ASPNETCORE_URLS=http://+:80 \n# ...\n```\n\nI'd like to change them for my application, because I don't like port 80 to be exposed.\nI am going with the port 5000, same as the default inside the development environment.\n\n\n```Dockerfile\n# Set listening host and port\nENV ASPNETCORE_URLS=http://+:5000\nEXPOSE 5000\n```\n\n## Summary\n\nWhen assembling all the different parts I stated above, you will end up with this final and complete Dockerfile:\n\n```Dockerfile\n# Build stage\nFROM mcr.microsoft.com/dotnet/sdk:5.0-alpine AS build\nWORKDIR /source\n\n# Copy csproj and restore as distinct layers\nCOPY . .\nRUN dotnet restore -r linux-musl-x64\n\nRUN dotnet test --no-restore\n\n# build swagger.json from controller/endpoint definitions\nRUN dotnet tool restore \\\n        dotnet swagger tofile --output swagger.json StartupProject/bin/Debug/net5.0/StartupProject.dll v1\n\n# release project (StartupProject is the startup project)\nRUN dotnet publish -c Release -o /appReleased -r linux-musl-x64 --self-contained true \\\n    --no-restore /p:PublishTrimmed=true /p:PublishReadyToRun=true StartupProject/*.csproj\n\n# Create final image\nFROM mcr.microsoft.com/dotnet/runtime-deps:5.0-alpine-amd64\nCOPY --from=build /appReleased /app\n\n# Add user, group, and change ownership\nRUN adduser --disabled-password --gecos \"\" --home /app --no-create-home --uid 10001 appuser \\\n    # make sure to allow your user to access your application binary\n    && chown -R appuser:appuser /app\n\nUSER appuser\n\n# Set listening host and port\nENV ASPNETCORE_URLS=http://+:5000\nEXPOSE 5000\n\nENTRYPOINT [\"/app/StartupProject\"]\n```\n\nFor me, it includes every aspect I care about and also has a minimal size with maximum security.\n\n","html":"<p>In this guide I’d like to show the most important topics and aspects when talking about containerizing a .NET 5.0 WebApi application.\nThere are many articles about it online but no one takes care of all aspects - until now.\nWith this guide you’d be able to go from zero :zero: to hero :mount_fuji: when talking about containers and .NET 5.0 WebApi.</p>\n<blockquote>\n<p>This articles focuses on building the app inside a Linux container.\nI won’t talk about .NET Framework (4.x) which would require the Windows platform to run.</p>\n</blockquote>\n<h3>What’s inside</h3>\n<p>The following topics are going to be considered in this guide:</p>\n<ul>\n<li>Configuration</li>\n<li>Testing</li>\n<li>OpenAPI spec (Swaggerfile) generation</li>\n<li>Image size optimizations</li>\n<li>Container security</li>\n<li>Overwriting defaults</li>\n</ul>\n<h2>Intial Dockerfile setup</h2>\n<p>This is the base version we are going to improve step by step in this guide.\nThe major downside is, that there is much more included in the\nfinal image than we need for production use.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">FROM</span> mcr.microsoft.com/dotnet/sdk:5.0-alpine <span class=\"token keyword\">AS</span> build</span>\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /source</span>\n\n<span class=\"token comment\"># Copy and restore</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n<span class=\"token comment\"># make sure this is set in the RuntimeIdentifiers of the .csproj</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> dotnet restore -r linux-musl-x64</span>\n\n<span class=\"token comment\"># publish project (StartupProject is the startup project)</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> dotnet publish -c Release -o /appReleased -r linux-musl-x64 <span class=\"token operator\">\\</span>\n    --no-restore StartupProject/*.csproj</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> [<span class=\"token string\">\"/appReleased/StartupProject\"</span>]</span></code></pre></div>\n<h2>Configuration</h2>\n<p>Application configuration is nowadays typically done in <code class=\"language-text\">appsettings.json</code>.\nNevertheless there are a bunch more configuration providers pre-built in the ASP .NET Core 5.0 framework.\nThese include the following:</p>\n<ul>\n<li>Environment variables</li>\n<li>Command line args</li>\n<li>Directory files</li>\n</ul>\n<p>In fact it does matter in which order you apply these setting because they can overwrite each other.\nThis powerful feature enables us to have some default configuration which can be overwritten at runtime.</p>\n<p>My way of configuring the application is a mixture of the <code class=\"language-text\">appsettings.json</code> file and environment variables.</p>\n<p>Since the settings file is a JSON, nesting is possible.\nWhen providing configuration with environment variables,\nyou should split these using <code class=\"language-text\">__</code> (a <code class=\"language-text\">double underline</code>).</p>\n<p>Taking the following file as example:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token comment\">// appsettings.json</span>\n<span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"JWT\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token property\">\"Secret\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"\"</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Assuming the configuration file from above,\noverwriting with environment variables\nis possible with the following statement:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token builtin class-name\">export</span> <span class=\"token assign-left variable\">JWT__Secret</span><span class=\"token operator\">=</span>superSecureJWTSecret</code></pre></div>\n<p>I don’t want the secrets like external API keys, JWT details, etc.\ninside my Git history, so they are provided as environment variables at application runtime.</p>\n<p>I’m using the settings file for a basic default configuration\nand the environment variables for the complete setup.\nAs already mentioned above, the environment variables will overwrite configuration done in\n<code class=\"language-text\">appsettings.json</code>, when the same key is provided. </p>\n<h2>Testing</h2>\n<p>Running tests every time you build your application is a crucial part of any CI pipeline,\nand executing them inside an isolated environment is even better.</p>\n<p>Running unit tests within the new .NET 5.0 ecosystem is as easy as calling a single command with the .NET CLI:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token instruction\"><span class=\"token keyword\">RUN</span> dotnet test --no-restore</span></code></pre></div>\n<p>Because we restored the project right before,\nwe do not need to restore again (which would be the default behaviour).\nThis implies that we can save some CI-Pipeline time with the <code class=\"language-text\">--no-restore</code> flag.</p>\n<h2>OpenAPI spec (Swaggerfile) generation</h2>\n<p>A very popular NuGet for a ASP .NET Core 5.0 projects is the\n<a href=\"https://www.nuget.org/packages/Swashbuckle.AspNetCore/\"><code class=\"language-text\">Swashbuckle.AspNetCore</code></a>\nwhich provides automatic OpenAPI generation.</p>\n<p>Most of the users may not know the dotnet CLI tool they provide.\nWith this tool it is possible to generate the OpenAPI spec directly\nfrom the startup assembly. </p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">dotnet tool <span class=\"token function\">install</span> --version <span class=\"token number\">6.1</span>.1 Swashbuckle.AspNetCore.Cli</code></pre></div>\n<blockquote>\n<p>:warning: Make sure you use the same version of the CLI tool\nand the NuGet, otherwise it will result in some strange error.</p>\n</blockquote>\n<p>There should now be a <code class=\"language-text\">dotnet-tools</code> config present, which stores all\ninstalled tools and corresponding versions.\nThis is important as this file is required for the build process later on.\nMake sure to also include it in your Git repository.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># build swagger.json from controller/endpoint definitions</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> dotnet tool restore <span class=\"token operator\">\\</span>\n        dotnet swagger tofile --output swagger.json StartupProject/bin/Debug/net5.0/StartupProject.dll v1</span></code></pre></div>\n<p>The OpenAPI specification is now written as JSON file inside the built image.\nYou can for example build a client with the OpenAPI toolkit or just save it for later use.</p>\n<p>For building a seperate client, another stage in your Dockerfile would be applicable.</p>\n<blockquote>\n<p>Official <a href=\"https://docs.docker.com/develop/develop-images/multistage-build/\">Docker docs on multi-stage builds</a></p>\n</blockquote>\n<h2>Image size and multi-staged builds</h2>\n<p>Until now the build process only spits out my own application and it’s dependencies.\nAs of now, the correct .NET runtime has to be installed and managed seperately.\nThis is also called <strong>framework-dependent</strong>.\nIndeed, there is another type of building and publishing an application.\nThat’s called the <strong>self-contained</strong> release.\nWhen using this, the runtime is provided together with the application code itself.\nAs a result, the runtime doesn’t need to be installed seperately.</p>\n<p>Another requirement for using <code class=\"language-text\">self-contained</code> as publishing type is, to make sure that the correct <code class=\"language-text\">RuntimeIdentifier</code> in your <code class=\"language-text\">.csproj</code> file is set.</p>\n<div class=\"gatsby-highlight\" data-language=\"xml\"><pre class=\"language-xml\"><code class=\"language-xml\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>Project</span> <span class=\"token attr-name\">Sdk</span><span class=\"token attr-value\"><span class=\"token punctuation attr-equals\">=</span><span class=\"token punctuation\">\"</span>Microsoft.NET.Sdk.Web<span class=\"token punctuation\">\"</span></span><span class=\"token punctuation\">></span></span>\n\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>PropertyGroup</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>TargetFramework</span><span class=\"token punctuation\">></span></span>net5.0<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>TargetFramework</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>RuntimeIdentifiers</span><span class=\"token punctuation\">></span></span>linux-musl-x64<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>RuntimeIdentifiers</span><span class=\"token punctuation\">></span></span>\n        <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>OutputType</span><span class=\"token punctuation\">></span></span>Exe<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>OutputType</span><span class=\"token punctuation\">></span></span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>PropertyGroup</span><span class=\"token punctuation\">></span></span>\n\n<span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>Project</span><span class=\"token punctuation\">></span></span></code></pre></div>\n<p>For the <strong>Alpine</strong> distribution as base image, the <code class=\"language-text\">linux-musl-x64</code> has to be added.\nYou may enable multiple RuntimeIdentifers (seperated by ”;”) in order\nto make it executable also on other platforms as self-contained build (for example <code class=\"language-text\">win-x64</code>).</p>\n<p>Now the finally built binary has fewer dependencies than the base image we used before provides.\nMicrosoft has also for this an answer: the base-image <code class=\"language-text\">mcr.microsoft.com/dotnet/runtime-deps:5.0-alpine-amd64</code>\nincludes everything just to run <code class=\"language-text\">self-contained</code> apps.</p>\n<p>It is now possible to switch to a multi-staged Docker build:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># Build stage</span>\n<span class=\"token instruction\"><span class=\"token keyword\">FROM</span> mcr.microsoft.com/dotnet/sdk:5.0-alpine <span class=\"token keyword\">AS</span> build</span>\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /source</span>\n\n<span class=\"token comment\"># Copy csproj and restore as distinct layers</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> dotnet restore -r linux-musl-x64</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> dotnet test --no-restore</span>\n\n<span class=\"token comment\"># build swagger.json from controller/endpoint definitions</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> dotnet tool restore <span class=\"token operator\">\\</span>\n        dotnet swagger tofile --output swagger.json StartupProject/bin/Debug/net5.0/StartupProject.dll v1</span>\n\n<span class=\"token comment\"># publish project (StartupProject is the startup project)</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> dotnet publish -c Release -o /appReleased -r linux-musl-x64 <span class=\"token operator\">\\</span>\n    --no-restore StartupProject/*.csproj</span>\n\n<span class=\"token comment\"># Create final image</span>\n<span class=\"token instruction\"><span class=\"token keyword\">FROM</span> mcr.microsoft.com/dotnet/runtime-deps:5.0-alpine-amd64</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--from</span><span class=\"token punctuation\">=</span><span class=\"token string\">build</span></span> /appReleased /app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> [<span class=\"token string\">\"/app/StartupProject\"</span>]</span></code></pre></div>\n<h2>Security</h2>\n<p>From the security point of view, it’s important to run your\nAPI in the context of a user with minimal operating system permissions.\nThe default if not specified would be the <code class=\"language-text\">root</code> user, but\nthere are multiple drawdowns when using the  superuser with Docker.</p>\n<p>However a detailed explanation would go beyond the scope of this article.</p>\n<blockquote>\n<p>You can follow along here for details: <a href=\"https://sysdig.com/blog/dockerfile-best-practices/\">https://sysdig.com/blog/dockerfile-best-practices/</a></p>\n</blockquote>\n<p>Running apps under another user is as easy as applying the following statements to your Dockerfile:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># (truncated)</span>\n<span class=\"token comment\"># Add user, group, and change ownership</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> adduser --disabled-password --gecos <span class=\"token string\">\"\"</span> --home /app --no-create-home --uid 10001 appuser <span class=\"token operator\">\\</span>\n    <span class=\"token comment\"># make sure to allow your user to access your application binary</span>\n    &amp;&amp; chown -R appuser:appuser /app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">USER</span> appuser</span>\n<span class=\"token comment\"># (truncated)</span></code></pre></div>\n<h2>Overriding defaults</h2>\n<p>In case you wondered where the default listening port is configured:\nI am going to demistify it now.</p>\n<p>The base image we are using here in the final layer has some default configuration\nand the listening URL and port is included there.</p>\n<blockquote>\n<p>You can view the base\n<a href=\"https://github.com/dotnet/dotnet-docker/blob/main/src/runtime-deps/3.1/alpine3.13/amd64/Dockerfile\">Dockerfile</a>\nhere</p>\n</blockquote>\n<p>The specific section I am talking about is this one:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># ...</span>\n<span class=\"token instruction\"><span class=\"token keyword\">ENV</span> <span class=\"token operator\">\\</span>\n    <span class=\"token comment\"># Configure web servers to bind to port 80 when present</span>\n    ASPNETCORE_URLS=http://+:80 </span>\n<span class=\"token comment\"># ...</span></code></pre></div>\n<p>I’d like to change them for my application, because I don’t like port 80 to be exposed.\nI am going with the port 5000, same as the default inside the development environment.</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># Set listening host and port</span>\n<span class=\"token instruction\"><span class=\"token keyword\">ENV</span> ASPNETCORE_URLS=http://+:5000</span>\n<span class=\"token instruction\"><span class=\"token keyword\">EXPOSE</span> 5000</span></code></pre></div>\n<h2>Summary</h2>\n<p>When assembling all the different parts I stated above, you will end up with this final and complete Dockerfile:</p>\n<div class=\"gatsby-highlight\" data-language=\"dockerfile\"><pre class=\"language-dockerfile\"><code class=\"language-dockerfile\"><span class=\"token comment\"># Build stage</span>\n<span class=\"token instruction\"><span class=\"token keyword\">FROM</span> mcr.microsoft.com/dotnet/sdk:5.0-alpine <span class=\"token keyword\">AS</span> build</span>\n<span class=\"token instruction\"><span class=\"token keyword\">WORKDIR</span> /source</span>\n\n<span class=\"token comment\"># Copy csproj and restore as distinct layers</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> . .</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> dotnet restore -r linux-musl-x64</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> dotnet test --no-restore</span>\n\n<span class=\"token comment\"># build swagger.json from controller/endpoint definitions</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> dotnet tool restore <span class=\"token operator\">\\</span>\n        dotnet swagger tofile --output swagger.json StartupProject/bin/Debug/net5.0/StartupProject.dll v1</span>\n\n<span class=\"token comment\"># release project (StartupProject is the startup project)</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> dotnet publish -c Release -o /appReleased -r linux-musl-x64 --self-contained true <span class=\"token operator\">\\</span>\n    --no-restore /p:PublishTrimmed=true /p:PublishReadyToRun=true StartupProject/*.csproj</span>\n\n<span class=\"token comment\"># Create final image</span>\n<span class=\"token instruction\"><span class=\"token keyword\">FROM</span> mcr.microsoft.com/dotnet/runtime-deps:5.0-alpine-amd64</span>\n<span class=\"token instruction\"><span class=\"token keyword\">COPY</span> <span class=\"token options\"><span class=\"token property\">--from</span><span class=\"token punctuation\">=</span><span class=\"token string\">build</span></span> /appReleased /app</span>\n\n<span class=\"token comment\"># Add user, group, and change ownership</span>\n<span class=\"token instruction\"><span class=\"token keyword\">RUN</span> adduser --disabled-password --gecos <span class=\"token string\">\"\"</span> --home /app --no-create-home --uid 10001 appuser <span class=\"token operator\">\\</span>\n    <span class=\"token comment\"># make sure to allow your user to access your application binary</span>\n    &amp;&amp; chown -R appuser:appuser /app</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">USER</span> appuser</span>\n\n<span class=\"token comment\"># Set listening host and port</span>\n<span class=\"token instruction\"><span class=\"token keyword\">ENV</span> ASPNETCORE_URLS=http://+:5000</span>\n<span class=\"token instruction\"><span class=\"token keyword\">EXPOSE</span> 5000</span>\n\n<span class=\"token instruction\"><span class=\"token keyword\">ENTRYPOINT</span> [<span class=\"token string\">\"/app/StartupProject\"</span>]</span></code></pre></div>\n<p>For me, it includes every aspect I care about and also has a minimal size with maximum security.</p>","timeToRead":7,"fields":{"slug":"/blog/2021/zero-to-hero-containerizing-dotnet-5-webapis/"},"frontmatter":{"title":"Zero to Hero: Containerizing .NET 5.0 WebApis","date":"July 10, 2021","description":"The ultimate guide for running your .NET 5.0 WebApi inside a Docker container.","image":{"childImageSharp":{"fluid":{"base64":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAUCAwQG/8QAFgEBAQEAAAAAAAAAAAAAAAAAAQAC/9oADAMBAAIQAxAAAAGWpbSaenOEf//EABkQAQEAAwEAAAAAAAAAAAAAAAIBAAMEMv/aAAgBAQABBQLzkpszo220b2Cmmv/EABcRAAMBAAAAAAAAAAAAAAAAAAABERL/2gAIAQMBAT8BqRo//8QAFxEBAAMAAAAAAAAAAAAAAAAAAAERIf/aAAgBAgEBPwHZU//EABsQAAIDAAMAAAAAAAAAAAAAAAABAhEhEkGR/9oACAEBAAY/AtWCNHDoqNeHJvT/xAAaEAEAAwADAAAAAAAAAAAAAAABABExQVFh/9oACAEBAAE/IeaoNWVg7kvsX7K4GZdgENFqn//aAAwDAQACAAMAAAAQYN//xAAXEQADAQAAAAAAAAAAAAAAAAAAARFR/9oACAEDAQE/EKYNMP/EABcRAAMBAAAAAAAAAAAAAAAAAAARIVH/2gAIAQIBAT8QgxtP/8QAGxABAAIDAQEAAAAAAAAAAAAAAQARITFRkeH/2gAIAQEAAT8QAQSWGMD4Wj5EXg8KmV/Rbre9wgQKlhRmcHKjR5P/2Q==","aspectRatio":1.5037593984962405,"src":"/static/46d24079b30ad7757c692625b74edeb0/3bf7d/esteban-lopez-6yjAC0-OwkA-unsplash.jpg","srcSet":"/static/46d24079b30ad7757c692625b74edeb0/fd013/esteban-lopez-6yjAC0-OwkA-unsplash.jpg 200w,\n/static/46d24079b30ad7757c692625b74edeb0/25252/esteban-lopez-6yjAC0-OwkA-unsplash.jpg 400w,\n/static/46d24079b30ad7757c692625b74edeb0/3bf7d/esteban-lopez-6yjAC0-OwkA-unsplash.jpg 640w","sizes":"(max-width: 640px) 100vw, 640px"}}}}}},"pageContext":{"slug":"/blog/2021/zero-to-hero-containerizing-dotnet-5-webapis/","previous":{"fields":{"slug":"/blog/2020/custom-mockups-for-onyx-boox-note-air/"},"frontmatter":{"title":"Custom Phone Mockups for Onyx Boox Note Air","categories":["creative","userinterface"]}},"next":{"fields":{"slug":"/blog/2021/strategy-design-pattern-with-di/"},"frontmatter":{"title":"Strategy Design Pattern with Dependency Injection","categories":["programming"]}}}},"staticQueryHashes":["143701507","3649515864"]}